options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: Practica1
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [184, 12]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \tdef __init__(self): # only default arguments here\n\t\tgr.sync_block.__init__(\n\
      \t\t\tself,\n\t\t\tname =\"e_Acum\", # will show up in GRC\n\t\t\tin_sig =[\
      \ np.float32 ],\n\t\t\tout_sig =[ np. float32 ]\n\t\t)\n\t\t\t\n\tdef work(self\
      \ , input_items , output_items ):\n\t\tx = input_items[0] # Senial de entrada\
      \ .\n\t\ty0 = output_items[0] # Senial acumulada\n\t\ty0[:] = np.cumsum(x)\n\
      \t\treturn len(y)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('e_Acum', 'blk', [], [('0', 'float', 1)], [('0', 'float', 1)], '',
      [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [360, 200.0]
    rotation: 0
    state: true
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\n\
      \n\tdef __init__(self): # only default arguments here\n\t\tgr.sync_block.__init__(\n\
      \t\t\tself,\n\t\t\tname=\"e_Diff\", # will show up in GRC\n\t\t\tin_sig=[np.float32],\n\
      \t\t\tout_sig=[np.float32]\n\t\t)\n\t\tself.acum_anterior=0\n\t\t\n\tdef work(self\
      \ , input_items , output_items ):\n\t\tx=input_items[0] # Senial de entrada\
      \ .\n\t\ty0=output_items[0] # Senial acumulada diferencial\n\t\t\n\t\tN=len(x)\n\
      \t\tdiff=np.cumsum(x)-self.acum_anterior\n\t\tself.acum_anterior = diff[N -1]\n\
      \t\ty0[:]=diff\n\t\treturn len(y)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('e_Diff', 'blk', [], [('0', 'float', 1)], [('0', 'float', 1)], '',
      [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [384, 256.0]
    rotation: 0
    state: true
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk (gr.sync_block\
      \ ):\n\n\tdef __init__ ( self ): # only default arguments here\n\t\tgr.sync_block.__init__(\n\
      \t\t\tself,\n\t\t\tname =\" Promedios_de_tiempos \", # will show up in GRC\n\
      \t\t\tin_sig =[ np.float32 ],\n\t\t\tout_sig =[ np.float32 ,np.float32 ,np.float32\
      \ ,np.float32 ,np.float32 ]\n\t\t)\n\t\tself.acum_anterior = 0\n\t\tself.Ntotales\
      \ = 0\n\t\tself.acum_anterior1 = 0\n\t\tself. cum_anterior2 = 0\n\n\tdef work\
      \ (self , input_items , output_items ):\n\t\tx = input_items[0] # Senial de\
      \ entrada .\n\t\ty0 = output_items[0] # Promedio de la senial\n\t\ty1 = output_items[1]\
      \ # Media de la senial\n\t\ty2 = output_items[2] # RMS de la senial\n\t\ty3\
      \ = output_items[3] # Potencia promedio de la senial\n\t\ty4 = output_items[4]\
      \ # Desviacion estandar de la senial\n\n\t\t# Calculo del promedio\n\t\tN =\
      \ len(x)\n\t\tself.Ntotales = self.Ntotales + N\n\t\tacumulado = self.acum_anterior\
      \ + np.cumsum(x)\n\t\tself.acum_anterior = acumulado[N -1]\t\n\t\ty0[:]= acumulado/self.Ntotales\n\
      \n\t\t# Calculo de la media cuadratica\n\t\tx2=np.multiply(x,x)\n\t\tacumulado1\
      \ = self.acum_anterior1 + np.cumsum(x2)\n\t\tself.acum_anterior1 = acumulado[N\
      \ -1]\n\t\ty1[:] = acumulado1/self.Ntotales\n\n\t\t# Calculo de la RMS\n\t\t\
      y2[:] = np.sqrt(y1)\n\t\n\t\t# Calculo de la potencia promedio\n\t\ty3[:] =\
      \ np.multiply(y2 ,y2)\n\t\n\t\t# Calculo de la desviacion estandar\n\t\tx3 =\
      \ np.multiply(x-y0 ,x-y0)\n\t\tacumulado2 = self.acum_anterior2 + np.cumsum(x3)\n\
      \t\tself.acum_anterior2 = acumulado2[N -1]\n\t\ty4[:] = np.sqrt( acumulado2\
      \ / self.Ntotales )\n\t\n\t\treturn len (x)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: (' Promedios_de_tiempos ', 'blk', [], [('0', 'float', 1)], [('0', 'float',
      1), ('1', 'float', 1), ('2', 'float', 1), ('3', 'float', 1), ('4', 'float',
      1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [336, 360.0]
    rotation: 0
    state: true
connections: []

metadata:
  file_format: 1
  grc_version: 3.9.8.0
